import { Account, AccountType, PaginatedResult, PaginationParams } from '@/types';
import { AccountsRepository, CreateAccountDTO, UpdateAccountDTO } from '@/repositories/contracts';
import { supabase } from './client';
import { 
  mapSupabaseAccountToDomain, 
  mapDomainAccountToSupabase,
  mapSupabaseAccountArrayToDomain 
} from './mappers';

export class SupabaseAccountsRepository implements AccountsRepository {
  async findById(id: string): Promise<Account | null> {
    const { data, error } = await supabase
      .from('accounts')
      .select('*')
      .eq('id', id)
      .single();
    
    if (error) {
      if (error.code === 'PGRST116') return null; // Not found
      throw new Error(`Failed to find account: ${error.message}`);
    }
    
    return mapSupabaseAccountToDomain(data);
  }

  async findAll(): Promise<Account[]> {
    // Get current session to obtain user_id
    const { data: { session } } = await supabase.auth.getSession();
    
    if (!session?.user?.id) {
      // No authenticated user, return empty array
      return [];
    }

    const { data, error } = await supabase
      .from('accounts')
      .select('*')
      .eq('active', true)
      .eq('user_id', session.user.id) // Filter by current user
      .order('created_at', { ascending: false });
    
    if (error) {
      throw new Error(`Failed to fetch accounts: ${error.message}`);
    }
    
    return mapSupabaseAccountArrayToDomain(data || []);
  }

  async findByUserId(userId: string): Promise<Account[]> {
    // Handle invalid user IDs gracefully
    if (!userId || userId === 'local-user' || userId === 'undefined' || userId === 'null') {
      return []; // Return empty array for invalid user IDs
    }
    
    const { data, error } = await supabase
      .from('accounts')
      .select('*')
      .eq('user_id', userId)
      .eq('active', true)
      .order('created_at', { ascending: false });
    
    if (error) {
      throw new Error(`Failed to fetch user accounts: ${error.message}`);
    }
    
    return mapSupabaseAccountArrayToDomain(data || []);
  }

  async findByType(type: AccountType): Promise<Account[]> {
    const { data, error } = await supabase
      .from('accounts')
      .select('*')
      .eq('type', type)
      .eq('active', true)
      .order('created_at', { ascending: false });
    
    if (error) {
      throw new Error(`Failed to fetch accounts by type: ${error.message}`);
    }
    
    return mapSupabaseAccountArrayToDomain(data || []);
  }

  async findByCurrency(currencyCode: string): Promise<Account[]> {
    const { data, error } = await supabase
      .from('accounts')
      .select('*')
      .eq('currency_code', currencyCode)
      .eq('active', true)
      .order('created_at', { ascending: false });
    
    if (error) {
      throw new Error(`Failed to fetch accounts by currency: ${error.message}`);
    }
    
    return mapSupabaseAccountArrayToDomain(data || []);
  }

  async create(accountData: CreateAccountDTO): Promise<Account> {
    const supabaseData = mapDomainAccountToSupabase({
      id: '', // Will be generated by database
      ...accountData,
      balance: accountData.balance || 0,
      active: true,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    });

    const { data, error } = await supabase
      .from('accounts')
      .insert(supabaseData)
      .select()
      .single();
    
    if (error) {
      throw new Error(`Failed to create account: ${error.message}`);
    }
    
    return mapSupabaseAccountToDomain(data);
  }

  async update(id: string, updateData: UpdateAccountDTO): Promise<Account> {
    const updatePayload = {
      ...(updateData.name && { name: updateData.name }),
      ...(updateData.type && { type: updateData.type }),
      ...(updateData.currencyCode && { currency_code: updateData.currencyCode }),
      ...(updateData.balance !== undefined && { balance: updateData.balance }),
      ...(updateData.active !== undefined && { active: updateData.active }),
      updated_at: new Date().toISOString(),
    };

    const { data, error } = await supabase
      .from('accounts')
      .update(updatePayload)
      .eq('id', id)
      .select()
      .single();
    
    if (error) {
      throw new Error(`Failed to update account: ${error.message}`);
    }
    
    return mapSupabaseAccountToDomain(data);
  }

  async delete(id: string): Promise<void> {
    // Soft delete by setting active to false
    const { error } = await supabase
      .from('accounts')
      .update({ active: false, updated_at: new Date().toISOString() })
      .eq('id', id);
    
    if (error) {
      throw new Error(`Failed to delete account: ${error.message}`);
    }
  }

  async findPaginated(params: PaginationParams): Promise<PaginatedResult<Account>> {
    const { page = 1, limit = 10, sortBy = 'createdAt', sortOrder = 'desc' } = params;
    const offset = (page - 1) * limit;
    
    const query = supabase
      .from('accounts')
      .select('*', { count: 'exact' })
      .eq('active', true)
      .range(offset, offset + limit - 1);
    
    // Apply sorting
    const sortColumn = sortBy === 'createdAt' ? 'created_at' : sortBy;
    query.order(sortColumn, { ascending: sortOrder === 'asc' });
    
    const { data, error, count } = await query;
    
    if (error) {
      throw new Error(`Failed to fetch paginated accounts: ${error.message}`);
    }
    
    return {
      data: mapSupabaseAccountArrayToDomain(data || []),
      total: count || 0,
      page,
      limit,
      totalPages: Math.ceil((count || 0) / limit),
    };
  }

  async getTotalBalance(userId: string): Promise<number> {
    const accounts = await this.findByUserId(userId);
    return accounts.reduce((total, account) => total + account.balance, 0);
  }



  async findActive(): Promise<Account[]> {
    const { data, error } = await supabase
      .from('accounts')
      .select('*')
      .eq('active', true)
      .order('created_at', { ascending: false });
    
    if (error) {
      throw new Error(`Failed to fetch active accounts: ${error.message}`);
    }
    
    return mapSupabaseAccountArrayToDomain(data || []);
  }

  async updateBalance(id: string, newBalance: number): Promise<Account> {
    const { data, error } = await supabase
      .from('accounts')
      .update({ 
        balance: newBalance,
        updated_at: new Date().toISOString()
      })
      .eq('id', id)
      .select()
      .single();
    
    if (error) {
      throw new Error(`Failed to update account balance: ${error.message}`);
    }
    
    return mapSupabaseAccountToDomain(data);
  }

  async adjustBalance(id: string, adjustment: number): Promise<Account> {
    // First get current balance
    const account = await this.findById(id);
    if (!account) {
      throw new Error(`Account not found: ${id}`);
    }
    
    const newBalance = account.balance + adjustment;
    return this.updateBalance(id, newBalance);
  }

  async updateBalances(updates: { id: string; newBalance: number }[]): Promise<Account[]> {
    const results: Account[] = [];
    
    // Process each update sequentially to maintain consistency
    for (const update of updates) {
      const result = await this.updateBalance(update.id, update.newBalance);
      results.push(result);
    }
    
    return results;
  }

  async getTotalBalanceByType(type: AccountType): Promise<number> {
    const { data, error } = await supabase
      .from('accounts')
      .select('balance')
      .eq('type', type)
      .eq('active', true);
    
    if (error) {
      throw new Error(`Failed to get total balance by type: ${error.message}`);
    }
    
    return (data || []).reduce((total, account) => total + (account.balance || 0), 0);
  }

  async getTotalBalanceByCurrency(currencyCode: string): Promise<number> {
    const { data, error } = await supabase
      .from('accounts')
      .select('balance')
      .eq('currency_code', currencyCode)
      .eq('active', true);
    
    if (error) {
      throw new Error(`Failed to get total balance by currency: ${error.message}`);
    }
    
    return (data || []).reduce((total, account) => total + (account.balance || 0), 0);
  }

  async getBalanceSummary(): Promise<{
    totalByType: Record<AccountType, number>;
    totalByCurrency: Record<string, number>;
    total: number;
  }> {
    const { data, error } = await supabase
      .from('accounts')
      .select('type, currency_code, balance')
      .eq('active', true);
    
    if (error) {
      throw new Error(`Failed to get balance summary: ${error.message}`);
    }
    
    const totalByType: Record<AccountType, number> = {
      [AccountType.CASH]: 0,
      [AccountType.BANK]: 0,
      [AccountType.CARD]: 0,
      [AccountType.SAVINGS]: 0,
      [AccountType.INVESTMENT]: 0,
    };
    
    const totalByCurrency: Record<string, number> = {};
    let total = 0;
    
    (data || []).forEach((account) => {
      const balance = account.balance || 0;
      
      // Sum by type
      if (account.type in totalByType) {
        totalByType[account.type as AccountType] += balance;
      }
      
      // Sum by currency
      if (!totalByCurrency[account.currency_code]) {
        totalByCurrency[account.currency_code] = 0;
      }
      totalByCurrency[account.currency_code] += balance;
      
      // Total sum
      total += balance;
    });
    
    return {
      totalByType,
      totalByCurrency,
      total,
    };
  }

  async createMany(data: CreateAccountDTO[]): Promise<Account[]> {
    const results: Account[] = [];
    
    // Process each create sequentially to maintain consistency
    for (const accountData of data) {
      const result = await this.create(accountData);
      results.push(result);
    }
    
    return results;
  }

  async deleteMany(ids: string[]): Promise<void> {
    // Soft delete by setting active to false
    const { error } = await supabase
      .from('accounts')
      .update({ active: false, updated_at: new Date().toISOString() })
      .in('id', ids);
    
    if (error) {
      throw new Error(`Failed to delete accounts: ${error.message}`);
    }
  }

  async count(): Promise<number> {
    const { count, error } = await supabase
      .from('accounts')
      .select('*', { count: 'exact', head: true })
      .eq('active', true);
    
    if (error) {
      throw new Error(`Failed to count accounts: ${error.message}`);
    }
    
    return count || 0;
  }

  async exists(id: string): Promise<boolean> {
    const { data, error } = await supabase
      .from('accounts')
      .select('id')
      .eq('id', id)
      .eq('active', true)
      .single();
    
    if (error) {
      if (error.code === 'PGRST116') return false; // Not found
      throw new Error(`Failed to check account existence: ${error.message}`);
    }
    
    return !!data;
  }
}
